#!/usr/bin/env python3
"""
Gmail No-Click Vulnerability Scanner
Tests for zero-click attack vectors that compromise accounts WITHOUT user interaction
"""

import imaplib
import email
import re
import json
from datetime import datetime, timedelta

class NoClickVulnerabilityScanner:
    def __init__(self):
        self.vulnerabilities = []
        self.mail = None
        
    def connect(self, email_address, password):
        """Connect to Gmail via IMAP"""
        try:
            print("ğŸ” Connecting to Gmail for vulnerability scan...")
            self.mail = imaplib.IMAP4_SSL('imap.gmail.com', 993)
            self.mail.login(email_address, password)
            print("âœ… Connected successfully!")
            return True
        except Exception as e:
            print(f"âŒ Connection failed: {e}")
            return False
    
    def scan_for_malicious_attachments(self):
        """Scan for potentially malicious attachments that could exploit zero-day vulnerabilities"""
        print("\nğŸ” Scanning for malicious attachments...")
        print("=" * 60)
        
        vulnerabilities = []
        
        try:
            self.mail.select('INBOX')
            
            # Search for emails with attachments in last 30 days
            date_threshold = (datetime.now() - timedelta(days=30)).strftime("%d-%b-%Y")
            status, messages = self.mail.search(None, f'(SINCE {date_threshold})')
            
            if status != 'OK':
                return vulnerabilities
            
            email_ids = messages[0].split()
            print(f"ğŸ“§ Scanning {len(email_ids)} recent emails...")
            
            dangerous_extensions = [
                '.exe', '.scr', '.bat', '.cmd', '.com', '.pif', '.vbs', '.js',
                '.jar', '.apk', '.pdf', '.doc', '.docx', '.xls', '.xlsx',
                '.ppt', '.pptx', '.rtf', '.zip', '.rar', '.7z'
            ]
            
            for email_id in email_ids[-20:]:  # Check last 20 emails
                status, msg_data = self.mail.fetch(email_id, '(RFC822)')
                if status != 'OK':
                    continue
                
                email_body = msg_data[0][1]
                email_message = email.message_from_bytes(email_body)
                
                # Check for attachments
                for part in email_message.walk():
                    if part.get_content_disposition() == 'attachment':
                        filename = part.get_filename()
                        if filename:
                            # Check for dangerous extensions
                            for ext in dangerous_extensions:
                                if filename.lower().endswith(ext):
                                    vulnerabilities.append({
                                        'type': 'MALICIOUS_ATTACHMENT',
                                        'severity': 'HIGH',
                                        'file': filename,
                                        'subject': email_message.get('Subject', 'No Subject'),
                                        'from': email_message.get('From', 'Unknown'),
                                        'risk': f'Potentially exploitable {ext} file'
                                    })
                                    print(f"âš ï¸  RISK: {filename} from {email_message.get('From', 'Unknown')}")
            
            print(f"âœ… Attachment scan complete: {len(vulnerabilities)} risks found")
            
        except Exception as e:
            print(f"âŒ Attachment scan error: {e}")
        
        return vulnerabilities
    
    def scan_for_phishing_links(self):
        """Scan for phishing links that could lead to credential theft"""
        print("\nğŸ” Scanning for phishing links...")
        print("=" * 60)
        
        vulnerabilities = []
        
        try:
            self.mail.select('INBOX')
            
            # Search recent emails
            date_threshold = (datetime.now() - timedelta(days=7)).strftime("%d-%b-%Y")
            status, messages = self.mail.search(None, f'(SINCE {date_threshold})')
            
            if status != 'OK':
                return vulnerabilities
            
            email_ids = messages[0].split()
            print(f"ğŸ“§ Scanning {len(email_ids)} emails for phishing...")
            
            # Suspicious patterns
            phishing_patterns = [
                r'https?://bit\.ly/\w+',  # Shortened URLs
                r'https?://tinyurl\.com/\w+',
                r'https?://[^/]*\.tk/',  # Free domains
                r'https?://[^/]*\.ml/',
                r'https?://[^/]*\.ga/',
                r'verify.*account',
                r'suspend.*account',
                r'unusual.*activity',
                r'confirm.*identity',
                r'urgent.*action',
                r'click.*here.*immediately',
            ]
            
            for email_id in email_ids[-10:]:  # Check last 10 emails
                status, msg_data = self.mail.fetch(email_id, '(RFC822)')
                if status != 'OK':
                    continue
                
                email_body = msg_data[0][1]
                email_message = email.message_from_bytes(email_body)
                
                # Extract body text
                body = ""
                if email_message.is_multipart():
                    for part in email_message.walk():
                        if part.get_content_type() == "text/plain":
                            body += str(part.get_payload(decode=True))
                        elif part.get_content_type() == "text/html":
                            body += str(part.get_payload(decode=True))
                else:
                    body = str(email_message.get_payload(decode=True))
                
                # Check for phishing patterns
                for pattern in phishing_patterns:
                    matches = re.findall(pattern, body, re.IGNORECASE)
                    if matches:
                        vulnerabilities.append({
                            'type': 'PHISHING_LINK',
                            'severity': 'CRITICAL',
                            'pattern': pattern,
                            'matches': matches[:3],  # First 3 matches
                            'subject': email_message.get('Subject', 'No Subject'),
                            'from': email_message.get('From', 'Unknown'),
                            'risk': 'Potential credential theft or malware download'
                        })
                        print(f"ğŸš¨ PHISHING DETECTED: {email_message.get('Subject', 'No Subject')}")
            
            print(f"âœ… Phishing scan complete: {len(vulnerabilities)} risks found")
            
        except Exception as e:
            print(f"âŒ Phishing scan error: {e}")
        
        return vulnerabilities
    
    def scan_for_spearphishing(self):
        """Scan for targeted spearphishing attacks"""
        print("\nğŸ” Scanning for spearphishing attacks...")
        print("=" * 60)
        
        vulnerabilities = []
        
        try:
            self.mail.select('INBOX')
            
            # Search for suspicious patterns
            suspicious_senders = [
                'admin@', 'security@', 'noreply@', 'support@',
                'verify@', 'account@', 'billing@'
            ]
            
            status, messages = self.mail.search(None, 'ALL')
            if status != 'OK':
                return vulnerabilities
            
            email_ids = messages[0].split()
            print(f"ğŸ“§ Analyzing {len(email_ids[-15:])} emails for spearphishing...")
            
            for email_id in email_ids[-15:]:  # Check last 15 emails
                status, msg_data = self.mail.fetch(email_id, '(RFC822)')
                if status != 'OK':
                    continue
                
                email_body = msg_data[0][1]
                email_message = email.message_from_bytes(email_body)
                
                sender = email_message.get('From', '')
                subject = email_message.get('Subject', '')
                
                # Check for suspicious sender patterns
                for pattern in suspicious_senders:
                    if pattern in sender.lower():
                        # Additional checks
                        if any(word in subject.lower() for word in ['verify', 'suspend', 'urgent', 'action required']):
                            vulnerabilities.append({
                                'type': 'SPEARPHISHING',
                                'severity': 'CRITICAL',
                                'from': sender,
                                'subject': subject,
                                'risk': 'Targeted attack mimicking legitimate service'
                            })
                            print(f"ğŸ¯ SPEARPHISHING: {subject} from {sender}")
            
            print(f"âœ… Spearphishing scan complete: {len(vulnerabilities)} risks found")
            
        except Exception as e:
            print(f"âŒ Spearphishing scan error: {e}")
        
        return vulnerabilities
    
    def check_account_security_settings(self):
        """Check for security misconfigurations that enable no-click attacks"""
        print("\nğŸ” Checking account security settings...")
        print("=" * 60)
        
        vulnerabilities = []
        
        print("ğŸ“‹ Security Settings Checklist:")
        print("   âš ï¸  Cannot programmatically check these - manual verification needed:")
        print("   1. Two-Factor Authentication (2FA) status")
        print("   2. Recovery phone/email configured")
        print("   3. Recent security activity")
        print("   4. Connected apps/devices")
        print("   5. Email forwarding rules")
        print("   6. POP/IMAP access settings")
        print("   7. Less secure app access")
        print("   8. Advanced Protection Program enrollment")
        
        vulnerabilities.append({
            'type': 'MANUAL_CHECK_REQUIRED',
            'severity': 'INFO',
            'action': 'Visit https://myaccount.google.com/security',
            'risk': 'Security settings need manual verification'
        })
        
        return vulnerabilities
    
    def scan_for_email_forwarding_rules(self):
        """Detect unauthorized email forwarding (common in no-click attacks)"""
        print("\nğŸ” Scanning for suspicious email forwarding...")
        print("=" * 60)
        
        print("âš ï¸  Email forwarding rules cannot be checked via IMAP")
        print("ğŸ“‹ Manual check required:")
        print("   1. Go to Gmail Settings â†’ Forwarding and POP/IMAP")
        print("   2. Check for unauthorized forwarding addresses")
        print("   3. Verify no suspicious filters exist")
        
        return [{
            'type': 'MANUAL_FORWARDING_CHECK',
            'severity': 'HIGH',
            'action': 'Check Gmail Settings â†’ Forwarding',
            'risk': 'Unauthorized forwarding can exfiltrate all emails'
        }]
    
    def perform_full_noclick_scan(self, email_address, password):
        """Perform comprehensive no-click vulnerability assessment"""
        print("ğŸš€ Gmail No-Click Vulnerability Scanner")
        print("=" * 60)
        print("âš ï¸  Scanning for zero-click attack vectors")
        print("âš ï¸  These attacks require NO user interaction!")
        print()
        
        # Connect
        if not self.connect(email_address, password):
            return
        
        all_vulnerabilities = []
        
        # Run all scans
        all_vulnerabilities.extend(self.scan_for_malicious_attachments())
        all_vulnerabilities.extend(self.scan_for_phishing_links())
        all_vulnerabilities.extend(self.scan_for_spearphishing())
        all_vulnerabilities.extend(self.check_account_security_settings())
        all_vulnerabilities.extend(self.scan_for_email_forwarding_rules())
        
        # Generate report
        self.generate_vulnerability_report(all_vulnerabilities)
        
        # Save to JSON
        self.save_report_to_json(all_vulnerabilities)
        
        return all_vulnerabilities
    
    def generate_vulnerability_report(self, vulnerabilities):
        """Generate comprehensive vulnerability report"""
        print("\n" + "=" * 60)
        print("ğŸ“Š NO-CLICK VULNERABILITY ASSESSMENT REPORT")
        print("=" * 60)
        
        # Count by severity
        critical = [v for v in vulnerabilities if v.get('severity') == 'CRITICAL']
        high = [v for v in vulnerabilities if v.get('severity') == 'HIGH']
        medium = [v for v in vulnerabilities if v.get('severity') == 'MEDIUM']
        low = [v for v in vulnerabilities if v.get('severity') == 'LOW']
        
        print(f"\nğŸ¯ VULNERABILITY SUMMARY:")
        print(f"   ğŸš¨ CRITICAL: {len(critical)} vulnerabilities")
        print(f"   âš ï¸  HIGH:     {len(high)} vulnerabilities")
        print(f"   âš¡ MEDIUM:   {len(medium)} vulnerabilities")
        print(f"   â„¹ï¸  LOW:      {len(low)} vulnerabilities")
        print(f"   ğŸ“Š TOTAL:    {len(vulnerabilities)} vulnerabilities")
        
        if critical:
            print(f"\nğŸš¨ CRITICAL VULNERABILITIES:")
            for v in critical:
                print(f"   âŒ {v['type']}: {v.get('risk', 'Unknown risk')}")
                if 'subject' in v:
                    print(f"      ğŸ“§ Subject: {v['subject']}")
                if 'from' in v:
                    print(f"      ğŸ‘¤ From: {v['from']}")
        
        if high:
            print(f"\nâš ï¸  HIGH VULNERABILITIES:")
            for v in high:
                print(f"   âš ï¸  {v['type']}: {v.get('risk', 'Unknown risk')}")
        
        print(f"\nğŸ’¡ SECURITY RECOMMENDATIONS:")
        print(f"   âœ… Enable 2FA (Two-Factor Authentication)")
        print(f"   âœ… Use App Passwords for IMAP access")
        print(f"   âœ… Enable Advanced Protection Program")
        print(f"   âœ… Review connected apps and devices")
        print(f"   âœ… Check email forwarding rules")
        print(f"   âœ… Enable security alerts")
        print(f"   âœ… Use unique, strong passwords")
        print(f"   âœ… Keep devices updated with latest security patches")
        print(f"   âœ… Avoid opening attachments from unknown senders")
        print(f"   âœ… Verify sender before clicking links")
        
        print(f"\nğŸ” NO-CLICK ATTACK PREVENTION:")
        print(f"   âœ… Keep OS and apps fully updated (patches zero-days)")
        print(f"   âœ… Disable auto-download of images in emails")
        print(f"   âœ… Use email client sandboxing")
        print(f"   âœ… Enable Gmail's Enhanced Safe Browsing")
        print(f"   âœ… Regularly audit account activity")
        print(f"   âœ… Use hardware security keys (YubiKey)")
        
        if len(vulnerabilities) == 0:
            print(f"\nğŸ‰ EXCELLENT! No major vulnerabilities detected!")
            print(f"   Your Gmail account appears secure against common no-click attacks.")
        else:
            print(f"\nâš ï¸  ACTION REQUIRED: {len(vulnerabilities)} vulnerabilities found!")
            print(f"   Review and remediate vulnerabilities immediately.")
    
    def save_report_to_json(self, vulnerabilities):
        """Save vulnerability report to JSON file"""
        report = {
            'scan_date': datetime.now().isoformat(),
            'scan_type': 'No-Click Vulnerability Assessment',
            'total_vulnerabilities': len(vulnerabilities),
            'vulnerabilities': vulnerabilities
        }
        
        filename = f"noclick_scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        with open(filename, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"\nğŸ“„ Report saved to: {filename}")

def main():
    """Main function"""
    print("ğŸ” Gmail No-Click Vulnerability Scanner")
    print("=" * 60)
    print("âš ï¸  Scans for zero-click attack vectors")
    print("âš ï¸  No user interaction required for these attacks!")
    print("âš ï¸  Use only on your own Gmail account")
    print()
    
    # Get credentials
    email_address = input("ğŸ“§ Enter your Gmail address: ")
    password = input("ğŸ”‘ Enter your Gmail app password: ")
    
    if not email_address or not password:
        print("âŒ Credentials required!")
        return
    
    # Create scanner
    scanner = NoClickVulnerabilityScanner()
    
    try:
        scanner.perform_full_noclick_scan(email_address, password)
    except KeyboardInterrupt:
        print("\nâ¹ï¸  Scan interrupted by user")
    except Exception as e:
        print(f"\nâŒ Error: {e}")
    finally:
        print(f"\nğŸ” Scan complete!")

if __name__ == "__main__":
    main()

